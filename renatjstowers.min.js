const PIVOT_HEIGHT = 14;
const TOWER_HEIGHT = 7;
const HELPER_PIVOTS = 2;
const GAMEHOST = "http://bashni.org";

const RANDOM_MAGIC_SEED = 58;
const FONT_FACTOR = 42;
const ERROR_NO_SUCH_COLUMN = -2;

var pivotCount;
var typesCount, disksCount;
var field, stackHeight;
var id_user;
var puzzle, moveNumber, optim, gamestatus = 0;
var movesHistory, scoresHistory;
var palette   = ['#003399', '#006600', '#d00000', '#c60095', '#009696', '#966400', '#b6dbde', '#f88000', '#e7f3a2', '#663300'];
var palette_digit = ['#c0c0b0', '#c0c0b0', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#c0c0b0'];
var palette_lower_edge = ['#000055', '#002200', '#800000', '#860055', '#005656', '#562400', '#768b8e', '#a83000', '#97a362', '#260000'];
var palette_upper_edge = ['#3366cc', '#339933', '#ff3333', '#ff33cc', '#33cccc', '#cc9933', '#eeffff', '#ffbb33', '#ffffdd', '#996633'];
var microsoft_rnd;
var lang_name = 0;

const MIN_DISK_WIDTH_RATIO = 0;
const MAX_DISK_WIDTH_RATIO = 0.9;

var canvas;
var context;
var cellWidth, cellHeight;
var contextWidth, contextHeight;
var minDiskWidth, maxDiskWidth;

var stackTopInfo, stackBottomInfo, stackHeight;
var stackStartCol = -1;
var stackStartRow;
var stackEndCol, stackEndRow;

const ANIMATION_TIME = 200;
const ANIMATION_NONE = 0;
const ANIMATION_UP = 1;
const ANIMATION_SIDE = 2;
const ANIMATION_DOWN = 3;

var animationState = ANIMATION_NONE;
var animationTimeStart;



function microsoft_rnd() {
    var r;
    var big = 4294967295 + 1;
    microsoft_rnd.seed = (microsoft_rnd.seed * 214013 + 2531011) % big;
    r = microsoft_rnd.seed;
    r = Math.floor(r / 65536);
    r = r % 32768;
    return r;
}

function microsoft_rand(number) {
    return (microsoft_rnd()) % number;
};

function rnd() {
    rnd.seed = (rnd.seed * 9301 + 49297) % 233280;
    return rnd.seed / (233280.0);
};

function rand(number) {
    return Math.floor(rnd() * number);
};

function startGame() {
    if ((puzzle <= 0) || (puzzle >= 1000000)) {
        puzzle = RANDOM_MAGIC_SEED;
    }
    
    microsoft_rnd.seed = puzzle;
    myform.puzzle.value = puzzle;
    
    shuffle();
    
    prepareCanvas();
    showTable();
    moveNumber = 0;
    optim = CalcOptim() + moveNumber;
    stackStartCol = -1;
    gamestatus = 1;
    showStatus();
}


function getFieldAt(row, col) {
    if ((row < 0) || (row >= PIVOT_HEIGHT) || (col < 0) || (col >= pivotCount)) {
        return -1;
    }
    return field[row * pivotCount + col];
}

function setFieldAt(row, col, val) {
    field[row * pivotCount + col] = val;
}

function getLabelAndColor(v) {
    if (v < 0) {
        return [-1, -1];
    }
    return [(v - 1) % TOWER_HEIGHT, Math.floor((v - 1) / TOWER_HEIGHT)];
}

function getLabelAndColorAt(row, col) {
    return getLabelAndColor(getFieldAt(row, col));
}

function LabelAndColorToValue(diskInfo) {
    return 1 + diskInfo[0] + TOWER_HEIGHT * diskInfo[1];
}

function CanMerge(firstDiskInfo, secondDiskInfo) {
    return (firstDiskInfo[1] == secondDiskInfo[1]) && (secondDiskInfo[0] == firstDiskInfo[0] + 1);
}

function CanMergeAt(row1, col1, row2, col2) {
    var firstDiskInfo = getLabelAndColorAt(row1, col1);
    var secondDiskInfo = getLabelAndColorAt(row2, col2);
    return CanMerge(firstDiskInfo, secondDiskInfo);
}

function CalcOptim() {
    var movesToMake = 0;
    for (var k = 0; k < pivotCount; ++k) {
        var diskInfo = getLabelAndColorAt(0, k);
        if (diskInfo[0] < 0) {
            continue;
        }
        if (diskInfo[0] != TOWER_HEIGHT - 1) {
            ++movesToMake;
        }
        for (var i = 1; i < PIVOT_HEIGHT - 1; ++i) {
            diskInfo = getLabelAndColorAt(i, k);
            if (diskInfo[0] < 0) {
                break;
            }
            if (!CanMergeAt(i, k, i - 1, k)) {
                ++movesToMake;
            }
        }
    }
    return movesToMake;
}


function undo() {
    if (moveNumber < 1) {
        return;
    }
    if (stackStartCol >= 0) {
        DownCell(stackStartCol);
        return;
    }
    --moveNumber;
    scoresHistory.pop();
    var lastMove = movesHistory.pop();
    var col1 = lastMove[0];
    var col2 = lastMove[1];
    var stackHeight = lastMove[2];
    var top1 = GetUp(col1);
    var top2 = GetUp(col2);
    for (var j = 0; j < stackHeight; j++) {
        var disk = getFieldAt(top2 - j, col2);
        setFieldAt(top1 - j + stackHeight, col1, disk);
        setFieldAt(top2 - j, col2, 0);
    }
    optim = CalcOptim() + moveNumber;
    showStatus();
    showTable();
}

function showStatus() {
    var vForecastStatus = document.getElementById('forecastStatus');
    var vUndoStatus = document.getElementById('undoStatus');
    if (gamestatus == 0) {
        vForecastStatus.innerHTML = "";
        vUndoStatus.innerHTML = "";
    } else {
        vForecastStatus.innerHTML = moveNumber + "[" + optim + "]";
        vUndoStatus.innerHTML = "<span class='undo'>Undo</span>";
    }
}


function relMouseCoords(event) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var currentElement = this;

    do {
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
    } while (currentElement = currentElement.offsetParent);
    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;
    return {x:canvasX, y:canvasY}
}

function prepareCanvas() {
    if (!canvas) {
        canvas = document.getElementById('board');
        context = canvas.getContext('2d');
        canvas.relMouseCoords = relMouseCoords;
        //canvas.addEventListener('touchstart', function (e) {e.preventDefault();}, true);
        canvas.addEventListener('click', move);
    }
}

function refreshCanvas() {
    contextWidth = canvas.clientWidth;
    contextHeight = canvas.clientHeight;
    if ((canvas.width != contextWidth) || (canvas.height != contextHeight)) {
        canvas.width = contextWidth;
        canvas.height = contextHeight;
    }
    cellWidth = contextWidth / pivotCount;
    cellHeight = contextHeight / (PIVOT_HEIGHT - 1);
    
    minDiskWidth = cellWidth * MIN_DISK_WIDTH_RATIO;
    maxDiskWidth = cellWidth * MAX_DISK_WIDTH_RATIO;
}

function drawTrapezoid(xLeftTop, xRightTop, yTop, xLeftBottom, xRightBottom, yBottom) {
    context.strokeStyle = "#000000";
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(xLeftTop, yTop);
    context.lineTo(xRightTop, yTop);
    context.lineTo(xRightBottom, yBottom);
    context.lineTo(xLeftBottom, yBottom);
    context.closePath();
    context.fill();
    context.stroke();    
}

function renderTrapezoid(lowerDiskInfo, upperDiskInfo, left, top, pointedTop) {
    if (lowerDiskInfo[0] < 0) {
        return;
    }
    context.fillStyle = palette[lowerDiskInfo[1]];
    var disksCount = lowerDiskInfo[0] - upperDiskInfo[0] + 1;
    var disksWidthRange = maxDiskWidth - minDiskWidth;
    
    //TODO: simplify
    var diskWidthTop;
    if (pointedTop && (!upperDiskInfo[0])) {
        diskWidthTop = 0;
    } else {
        diskWidthTop = minDiskWidth + (upperDiskInfo[0] + 1) / (TOWER_HEIGHT + 2) * disksWidthRange;
    }
    var diskOffsetTop = (cellWidth - diskWidthTop) / 2;
    
    var xTopLeft = left + diskOffsetTop;
    var xTopRight = left + cellWidth - diskOffsetTop;
    var yTop = top;
    
    var diskWidthBottom = minDiskWidth + (lowerDiskInfo[0] + 2) / (TOWER_HEIGHT + 2) * disksWidthRange;
    var diskOffsetBottom = (cellWidth - diskWidthBottom) / 2;
    
    var xBottomLeft = left + diskOffsetBottom;
    var xBottomRight = left + cellWidth - diskOffsetBottom;
    var yBottom = yTop + disksCount * cellHeight;
    
    if (pointedTop && (!upperDiskInfo[0])) {
        yTop -= cellHeight;
    }
    drawTrapezoid(xTopLeft, xTopRight, yTop, xBottomLeft, xBottomRight, yBottom);
    
    context.fillStyle = palette_digit[lowerDiskInfo[1]];
    for (var diskValue = upperDiskInfo[0]; diskValue <= lowerDiskInfo[0]; ++diskValue) {
        if (diskValue) {
            context.fillText(diskValue, left + 0.5 * cellWidth, top + (diskValue - upperDiskInfo[0] + 0.5) * cellHeight);
        }
    }
}

function animateUp(timestamp) {
    if (animationState != ANIMATION_UP) {
        animationState = ANIMATION_UP;
        animationTimeStart = timestamp;
    }
    
    showTable();
    var progress = Math.min((timestamp - animationTimeStart) / ANIMATION_TIME, 1);
    var y = cellHeight * ((PIVOT_HEIGHT - 1 - stackStartRow) - (PIVOT_HEIGHT - 2 - stackStartRow + stackHeight) * progress);
    renderTrapezoid(stackBottomInfo, stackTopInfo, stackStartCol * cellWidth, y, true);
    
    if (timestamp - animationTimeStart > ANIMATION_TIME) {
        animationState = ANIMATION_NONE;
        return;
    }
    requestAnimationFrame(animateUp, canvas);
}

function animateSide(timestamp) {
    if (animationState != ANIMATION_SIDE) {
        animationState = ANIMATION_SIDE;
        animationTimeStart = timestamp;
    }
    
    showTable();
    var progress = Math.min((timestamp - animationTimeStart) / ANIMATION_TIME, 1);
    var x = stackStartCol * cellWidth - (stackStartCol - stackEndCol) * cellWidth * progress;
    renderTrapezoid(stackBottomInfo, stackTopInfo, x, -cellHeight * (stackHeight - 1), true);
    
    if (timestamp - animationTimeStart > ANIMATION_TIME) {
        animationState = ANIMATION_NONE;
        requestAnimationFrame(animateDown, canvas);
        return;
    }
    requestAnimationFrame(animateSide, canvas);
}

function animateDown(timestamp) {
    if (animationState != ANIMATION_DOWN) {
        animationState = ANIMATION_DOWN;
        animationTimeStart = timestamp;
    }
    
    showTable();
    
    var progress = Math.min((timestamp - animationTimeStart) / ANIMATION_TIME, 1);
    var y = -cellHeight * (stackHeight - 1) + cellHeight * (PIVOT_HEIGHT - 2 - stackEndRow) * progress;
    renderTrapezoid(stackBottomInfo, stackTopInfo, stackEndCol * cellWidth, y, true);
    
    if (timestamp - animationTimeStart > ANIMATION_TIME) {
        EndDownCell();
        animationState = ANIMATION_NONE;
        return;
    }
    requestAnimationFrame(animateDown, canvas);
}

function showTable() {
    //TODO: handle it in more pleasant way
    refreshCanvas();    
    
    context.font = (canvas.width / FONT_FACTOR) + "px Sans-serif";
    context.textAlign = "center";
    context.textBaseline = "middle";
        
    for (var j = 0; j < pivotCount; j++) {    
        context.fillStyle = (j & 1) ? "rgb(255, 240, 240)": "bisque";
        context.fillRect(
            Math.floor(j * cellWidth), 0, Math.floor(cellWidth), contextHeight
        );
        var lowerDiskInfo = [-1, -1];
        var upperDiskInfo = [-1, -1];
        for (var i = PIVOT_HEIGHT; i--; ) {            
            var diskInfo = getLabelAndColorAt(PIVOT_HEIGHT - 1 - i, j);
            if (!CanMerge(diskInfo, upperDiskInfo)) {
                renderTrapezoid(lowerDiskInfo, upperDiskInfo, j * cellWidth, i * cellHeight, diskInfo[0] < 0);
                lowerDiskInfo = diskInfo;
                upperDiskInfo = diskInfo;
            } else {
                upperDiskInfo = diskInfo;
            }
        }
        renderTrapezoid(lowerDiskInfo, upperDiskInfo, j * cellWidth, i * cellHeight, true);
    }
}

function GetUp(col) {
    col = parseInt(col);
    if ((col < 0) || (col > pivotCount - 1)) {
        return ERROR_NO_SUCH_COLUMN;
    }
    var i = 0;
    while (getFieldAt(i, col) && (i < PIVOT_HEIGHT - 1)) {
        ++i;
    }
    return --i;
}

function GetStackHeight(col, r) {
    var i = r;
    while (CanMergeAt(i, col, i - 1, col)) {
        --i;
    }
    return r - i + 1;
}

function UpCell(col) {
    var upperDisk = GetUp(col);
    if (upperDisk >= 0) {
        var h = GetStackHeight(col, upperDisk);
        stackStartCol = col;
        stackStartRow = upperDisk + 1;
        stackTopInfo = getLabelAndColorAt(upperDisk, col);
        stackBottomInfo = getLabelAndColorAt(upperDisk - h + 1, col);
        stackHeight = h;
        for (var j = upperDisk - h + 1; j <= upperDisk; j++) {
            setFieldAt(j, col, 0);
        }
       
        requestAnimationFrame(animateUp, canvas); 
    }
}

function DownCell(col) {
    col = parseInt(col);
    var canput = 0;
    var r = GetUp(col);
    if (r >= 0) {
        var diskInfo = getLabelAndColorAt(r, col);
        if ((diskInfo[1] == stackBottomInfo[1]) && (diskInfo[0] > stackBottomInfo[0]) && (col != stackStartCol)) {
            canput = 1;
        }
    } else if (col != stackStartCol) {
        canput = 1;
    }
    if (r == ERROR_NO_SUCH_COLUMN) {
        canput = 0;
    }
        
    stackEndCol = (canput) ? col : stackStartCol;
    stackEndRow = GetUp(stackEndCol) + 1;
    //TODO: animate side and down
    if (canput) {
        requestAnimationFrame(animateSide, canvas);
    } else {
        EndDownCell();
    }
    
}

function EndDownCell() {
    
    var diskInfo = stackBottomInfo;
    for (var j = 0; j < stackHeight; j++) {
        setFieldAt(stackEndRow + j, stackEndCol, LabelAndColorToValue(diskInfo));
        --diskInfo[0];
    }
    
    if (stackEndCol != stackStartCol) {
        movesHistory.push([stackStartCol, stackEndCol, stackHeight]);
        scoresHistory.push(stackStartCol + stackEndCol * 12);
        ++moveNumber;
    }
    
    showTable();
    optim = CalcOptim() + moveNumber;
    stackStartCol = -1;
    showStatus();
    if (checkEnd()) {
        gamestatus = 0;
        saveResult();
    }
}

function checkEnd() {
    if (moveNumber > 199) {
        return 1;
    }
    for (var i = 0; i < pivotCount; i++) {
        var r = GetUp(i);
        if (r >= 0) {
            j = 0;
            var a = getFieldAt(j, i);
            var m2 = Math.floor((a - 1) / 7);
            for (j = 0; j < 7; j++) {
                var a = field[j * pivotCount + i];
                k1 = (a - 1) % 7;
                k2 = Math.floor((a - 1) / 7);
                if (k2 != m2) return 0;
                if (k1 != 6 - j) return 0;
            }
        }
    }
    return 1;
}

function saveResult() {
    var i, k;
    hist = '';
    for (var i = 0; i < scoresHistory.length; ++i) {
        hist += (scoresHistory[i] % 12).toString(16);
        hist += (scoresHistory[i] / 12).toString(16);
    }
    s = GAMEHOST + 
        '/cgi-bin/savescore_drupal.pl?id=' + id_user +
        '&score=' + moveNumber +
        '&puzzle=' + puzzle +
        '&status=' + pivotCount +
        '&h=' + hist +
        '&lang=' + lang_name;
    window.location.replace(s);
}

function move(obj) {
    if (animationState != ANIMATION_NONE) {
            return;
    }
    refreshCanvas();
    var mousePos = canvas.relMouseCoords(obj);
    var mouseX = mousePos.x;
    var mouseY = mousePos.y;
    
    if (gamestatus < 1) {
        return;
    }
    var col = Math.floor(mouseX * pivotCount / contextWidth);
    if (stackStartCol >= 0) {
        DownCell(col);
    } else {
        UpCell(col);
    }
    obj.preventDefault();
}

function shuffle() {
    var t, i, j, s, frac, a2, tloop;
    window.status = "Loading ";
    var b = new Array(72);
    for (k = 0; k < 72; k++) {
        b[k] = k + 1;
    }
    for (k = 0; k < pivotCount; k++) {
        for (i = 0; i < PIVOT_HEIGHT; i++) {
            j = i * pivotCount + k;
            field[j] = 0;
        }
    }
    goodBoardFound = 0;
    tloop = 2300;
    var round = puzzle;
    var cic = 0,
        cic2 = 0;
        
    while (!goodBoardFound) {
        cic++;
        if (cic == 1000) {
            cic2++;
            window.status = "Loading " + cic2 + "%";
            cic = 0;
        }
        for (k = 0; k < tloop; k++) {
            i = microsoft_rand(disksCount);
            j = microsoft_rand(disksCount);
            m = b[i];
            b[i] = b[j];
            b[j] = m;
        }
        tloop = 1;
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < pivotCount; k++) {
                j = i * pivotCount + k;
                field[j] = b[m];
                m++;
            }
        }
        k = 6 * pivotCount;
        while (k > disksCount) {
            k--;
            field[k] = 0;
        }
        if (round < 60000) {
            goodBoardFound = 1;
        } else {
            a2 = CalcOptim();
            if (a2 < disksCount - 9) {
                goodBoardFound = 1;
            }
            tloop = 0;
            i = microsoft_rand(pivotCount * 4);
            j = (b[i] - 1) % 7;
            if (j > 0) {
                j = b[i] - 1;
                k = 0;
                while (b[k] != j && k < disksCount) {
                    k++;
                }
                j = b[i + pivotCount];
                b[i + pivotCount] = b[k];
                b[k] = j;
            }
        }
    }
    if (pivotCount < 12) {
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < pivotCount; k++) {
                j = i * pivotCount + k;
                field[j] = b[m];
                m++;
            }
        }
        k = 6 * pivotCount;
        while (k > disksCount) {
            k--;
            field[k] = 0;
        }
    }
    window.status = "";
}

function loadBoard(idu, puz, status, lang_id) {
    lang_name = lang_id;
    pivotCount = status;
    if (pivotCount != 12 && pivotCount != 10 && pivotCount != 8) {
        pivotCount = 12;
    }
    typesCount = pivotCount - HELPER_PIVOTS;
    disksCount = TOWER_HEIGHT * typesCount;
    puzzle = puz;
    id_user = idu;
    gamestatus = 0;
    field = new Array(pivotCount * PIVOT_HEIGHT);
    movesHistory = new Array();
    scoresHistory = new Array();
    for (var k = 0; k < pivotCount; k++) {
        for (var i = 0; i < PIVOT_HEIGHT; i++) {
            var j = i * pivotCount + k;
            field[j] = 0;
        }
    }
    startGame();
}