var PIVOT_HEIGHT = 14;
var TOWER_HEIGHT = 7;
var HELPER_PIVOTS = 2;
var GAMEHOST = "http://bashni.org";

var RANDOM_MAGIC_SEED = 58;
var FONT_SIZE = 24;
var ERROR_NO_SUCH_COLUMN = -2;

var pivotCount;
var typesCount, disksCount;
var field, stackHeight;
var id_user;
var puzzle, moveNumber, optim, gamestatus = 0;
var movesHistory, scoresHistory;
var palette   = ['#003399', '#006600', '#d00000', '#c60095', '#009696', '#966400', '#b6dbde', '#f88000', '#e7f3a2', '#663300'];
var palette_digit = ['#c0c0b0', '#c0c0b0', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#c0c0b0'];
var microsoft_rnd;
var lang_name = 0;


var canvas;
var context;
var contextWidth, contextHeight;

var stackTop, stackBottom, stackHeight;
var stackCol = -1;

function microsoft_rnd() {
    var r;
    var big = 4294967295 + 1;
    microsoft_rnd.seed = (microsoft_rnd.seed * 214013 + 2531011) % big;
    r = microsoft_rnd.seed;
    r = Math.floor(r / 65536);
    r = r % 32768;
    return r;
}

function microsoft_rand(number) {
    return (microsoft_rnd()) % number;
};

function rnd() {
    rnd.seed = (rnd.seed * 9301 + 49297) % 233280;
    return rnd.seed / (233280.0);
};

function rand(number) {
    return Math.floor(rnd() * number);
};

function startGame() {
    if ((puzzle <= 0) || (puzzle >= 1000000)) {
        puzzle = RANDOM_MAGIC_SEED;
    }
    
    microsoft_rnd.seed = puzzle;
    myform.puzzle.value = puzzle;
    
    shuffle();
    
    prepareCanvas();
    showTable();
    moveNumber = 0;
    optim = CalcOptim() + moveNumber;
    stackCol = -1;
    gamestatus = 1;
    showStatus();
}


function getFieldAt(row, col) {
    if ((row < 0) || (row >= PIVOT_HEIGHT) || (col < 0) || (col >= pivotCount)) {
        return -1;
    }
    return field[row * pivotCount + col];
}

function setFieldAt(row, col, val) {
    field[row * pivotCount + col] = val;
}

function getLabelAndColor(v) {
    if (v < 0) {
        return [-1, -1];
    }
    return [(v - 1) % TOWER_HEIGHT, Math.floor((v - 1) / TOWER_HEIGHT)];
}

function getLabelAndColorAt(row, col) {
    return getLabelAndColor(getFieldAt(row, col));
}

function LabelAndColorToValue(diskInfo) {
    return 1 + diskInfo[0] + TOWER_HEIGHT * diskInfo[1];
}

function CanMerge(row1, col1, row2, col2) {
    var firstDiskInfo = getLabelAndColorAt(row1, col1);
    var secondDiskInfo = getLabelAndColorAt(row2, col2);
    return (firstDiskInfo[1] == secondDiskInfo[1]) && (secondDiskInfo[0] == firstDiskInfo[0] + 1);
}

function CalcOptim() {
    var movesToMake = 0;
    for (var k = 0; k < pivotCount; ++k) {
        var diskInfo = getLabelAndColorAt(0, k);
        if (diskInfo[0] < 0) {
            continue;
        }
        if (diskInfo[0] != TOWER_HEIGHT - 1) {
            ++movesToMake;
        }
        for (var i = 1; i < PIVOT_HEIGHT - 1; ++i) {
            diskInfo = getLabelAndColorAt(i, k);
            if (diskInfo[0] < 0) {
                break;
            }
            if (!CanMerge(i, k, i - 1, k)) {
                ++movesToMake;
            }
        }
    }
    return movesToMake;
}


function undo() {
    if (moveNumber < 1) {
        return;
    }
    if (stackCol >= 0) {
        DownCell(stackCol);
        return;
    }
    --moveNumber;
    scoresHistory.pop();
    var lastMove = movesHistory.pop();
    var col1 = lastMove[0];
    var col2 = lastMove[1];
    var stackHeight = lastMove[2];
    var top1 = GetUp(col1);
    var top2 = GetUp(col2);
    for (var j = 0; j < stackHeight; j++) {
        var disk = getFieldAt(top2 - j, col2);
        setFieldAt(top1 - j + stackHeight, col1, disk);
        setFieldAt(top2 -j, col2, 0);
    }
    optim = CalcOptim() + moveNumber;
    showStatus();
    showTable();
}

function showStatus() {
    var vForecastStatus = document.getElementById('forecastStatus');
    var vUndoStatus = document.getElementById('undoStatus');
    if (gamestatus == 0) {
        vForecastStatus.innerHTML = "";
        vUndoStatus.innerHTML = "";
    } else {
        vForecastStatus.innerHTML = moveNumber + "[" + optim + "]";
        vUndoStatus.innerHTML = "<span class='undo'>Undo</span>";
    }
}


function relMouseCoords(event) {
    var totalOffsetX = 0;
    var totalOffsetY = 0;
    var canvasX = 0;
    var canvasY = 0;
    var currentElement = this;

    do {
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
    } while (currentElement = currentElement.offsetParent);
    canvasX = event.pageX - totalOffsetX;
    canvasY = event.pageY - totalOffsetY;
    return {x:canvasX, y:canvasY}
}

function prepareCanvas() {
    if (!canvas) {
        canvas = document.getElementById('board');
        context = canvas.getContext('2d');
        contextWidth = canvas.clientWidth;
        contextHeight = canvas.clientHeight;
        canvas.relMouseCoords = relMouseCoords;
        canvas.addEventListener('click', move);
    }
}

function showTable() {
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    var cellWidth = contextWidth / pivotCount;
    var cellHeight = contextHeight / PIVOT_HEIGHT;
    
    cellHeight = cellWidth * 0.3;
    
    var minDiskWidth = cellWidth * 0;
    var maxDiskWidth = cellWidth * 0.8;
    
    context.font = FONT_SIZE + "px Sans-serif";
    context.textAlign = "center";
    context.textBaseline = "middle";
    //TODO: remember that bgcolor='#afaf5f' class='bigcell'
    for (var i = PIVOT_HEIGHT; i--; ) {
        for (var j = 0; j < pivotCount; j++) {
            if (i == PIVOT_HEIGHT - 1) {
                context.fillStyle = (j & 1) ? "rgb(255, 240, 240)": "bisque";
                context.fillRect(
                    Math.floor(j * cellWidth), 0, Math.floor(cellWidth), contextHeight
                );
            }            
                        
            var diskInfo = getLabelAndColorAt(PIVOT_HEIGHT - 1 - i, j);
            if (diskInfo[0] == -1) {
                continue;
            }
            
            var diskWidthTop = minDiskWidth + diskInfo[0] / (TOWER_HEIGHT - 1) * (maxDiskWidth - minDiskWidth);
            var diskWidthBottom = minDiskWidth + (diskInfo[0] + 1) / (TOWER_HEIGHT - 1) * (maxDiskWidth - minDiskWidth);
            var diskOffsetTop = (cellWidth - diskWidthTop) / 2;
            var diskOffsetBottom = (cellWidth - diskWidthBottom) / 2;
                            
            //TODO: done=1 if under the cell is sequential growth
            context.fillStyle = palette[diskInfo[1]];  
            
            var xLeftTop = Math.floor(j * cellWidth + diskOffsetTop);
            var xRightTop = Math.floor((j + 1) * cellWidth - diskOffsetTop); 
            var yTop = Math.floor(i * cellHeight);
            var xLeftBottom = Math.floor(j * cellWidth + diskOffsetBottom);
            var xRightBottom = Math.floor((j + 1) * cellWidth - diskOffsetBottom);
            var yBottom = Math.floor((i + 1) * cellHeight);
            
            context.beginPath();
            context.moveTo(xLeftTop, yTop);
            context.lineTo(xRightTop, yTop);
            context.lineTo(xRightBottom, yBottom);
            context.lineTo(xLeftBottom, yBottom);
            context.closePath();
            context.fill();
            
            context.beginPath();
            context.moveTo(xRightTop, yTop);
            context.lineTo(xRightBottom, yBottom);
            context.moveTo(xLeftTop, yTop);
            context.lineTo(xLeftBottom, yBottom);
            context.closePath();
            context.fill();
            
            context.stroke();
            context.fillStyle = palette_digit[diskInfo[1]];
            
            if (diskInfo[0]) {
                context.fillText(diskInfo[0], (j + 0.5) * cellWidth, (i + 0.5) * cellHeight);
            }
                            
            //for row and col to return: 
            //k = PIVOT_HEIGHT - 1 - i;
            //id='a_" + k + "_" + j + "'"
            //onclick='move(this)' 
            //class='ground'>";
        
        }
    }
    context.setTransform(1, 0, 0, 1, 0, 0);
}

function GetUp(col) {
    col = parseInt(col);
    if ((col < 0) || (col > pivotCount - 1)) {
        return ERROR_NO_SUCH_COLUMN;
    }
    var i = 0;
    while (getFieldAt(i, col) && (i < PIVOT_HEIGHT - 1)) {
        ++i;
    }
    return --i;
}

function GetStackHeight(col, r) {
    var i = r;
    while (CanMerge(i, col, i - 1, col)) {
        --i;
    }
    return r - i + 1;
}

function UpCell(col) {
    var upperDisk = GetUp(col);
    if (upperDisk >= 0) {
        var h = GetStackHeight(col, upperDisk);
        stackCol = col;
        stackTop = getFieldAt(upperDisk, col);
        stackBottom = getFieldAt(upperDisk - h + 1, col);
        stackHeight = h;
        for (var j = upperDisk - h + 1; j <= upperDisk; j++) {
            setFieldAt(j, col, 0);
        }
        //TODO: pretty animation
        setFieldAt(PIVOT_HEIGHT - 1, col, stackBottom);
        showTable();
    }
}

function DownCell(col) {
    col = parseInt(col);
    var canput = 0;
    var r = GetUp(col);
    if (r >= 0) {
        var diskInfo = getLabelAndColorAt(r, col);
        var stackBottomInfo = getLabelAndColor(stackBottom);
        if ((diskInfo[1] == stackBottomInfo[1]) && (diskInfo[0] > stackBottomInfo[0]) && (col != stackCol)) {
            canput = 1;
        }
    } else if (col != stackCol) {
        canput = 1;
    }
    if (r == ERROR_NO_SUCH_COLUMN) {
        //TODO: check logic
        canput = 0;
    }
    
    setFieldAt(PIVOT_HEIGHT - 1, stackCol, 0);
    
    var putCol = (canput) ? col : stackCol;
        
    var bottomRow = GetUp(putCol) + 1;
    var diskInfo = getLabelAndColor(stackBottom);
    for (var j = 0; j < stackHeight; j++) {
        setFieldAt(bottomRow + j, putCol, LabelAndColorToValue(diskInfo));
        --diskInfo[0];
    }
    
    if (canput) {
        movesHistory.push([stackCol, col, stackHeight]);
        scoresHistory.push(stackCol + col * 12);
        moveNumber++;
    }
    
    showTable();
    optim = CalcOptim() + moveNumber;
    stackCol = -1;
    showStatus();
    if (checkEnd()) {
        gamestatus = 0;
        saveResult();
    }
}

function checkEnd() {
    if (moveNumber > 199) {
        return 1;
    }
    for (var i = 0; i < pivotCount; i++) {
        var r = GetUp(i);
        if (r >= 0) {
            j = 0;
            var a = getFieldAt(j, i);
            var m2 = Math.floor((a - 1) / 7);
            for (j = 0; j < 7; j++) {
                var a = field[j * pivotCount + i];
                k1 = (a - 1) % 7;
                k2 = Math.floor((a - 1) / 7);
                if (k2 != m2) return 0;
                if (k1 != 6 - j) return 0;
            }
        }
    }
    return 1;
}

function saveResult() {
    var i, k;
    hist = '';
    for (var i = 0; i < scoresHistory.length; ++i) {
        hist += (scoresHistory[i] % 12).toString(16);
        hist += (scoresHistory[i] / 12).toString(16);
    }
    s = GAMEHOST + 
        '/cgi-bin/savescore_drupal.pl?id=' + id_user +
        '&score=' + moveNumber +
        '&puzzle=' + puzzle +
        '&status=' + pivotCount +
        '&h=' + hist +
        '&lang=' + lang_name;
    window.location.replace(s);
}

function move(obj) {
    var mousePos = canvas.relMouseCoords(obj);
    var mouseX = mousePos.x;
    var mouseY = mousePos.y;
    
    if (gamestatus < 1) {
        return;
    }
    var col = Math.floor(mouseX * pivotCount / contextWidth);
    if (stackCol >= 0) {
        DownCell(col);
    } else {
        UpCell(col);
    }
    return;
}

function shuffle() {
    var t, i, j, s, frac, a2, tloop;
    window.status = "Loading ";
    var b = new Array(72);
    for (k = 0; k < 72; k++) {
        b[k] = k + 1;
    }
    for (k = 0; k < pivotCount; k++) {
        for (i = 0; i < PIVOT_HEIGHT; i++) {
            j = i * pivotCount + k;
            field[j] = 0;
        }
    }
    goodBoardFound = 0;
    tloop = 2300;
    var round = puzzle;
    var cic = 0,
        cic2 = 0;
        
    while (!goodBoardFound) {
        cic++;
        if (cic == 1000) {
            cic2++;
            window.status = "Loading " + cic2 + "%";
            cic = 0;
        }
        for (k = 0; k < tloop; k++) {
            i = microsoft_rand(disksCount);
            j = microsoft_rand(disksCount);
            m = b[i];
            b[i] = b[j];
            b[j] = m;
        }
        tloop = 1;
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < pivotCount; k++) {
                j = i * pivotCount + k;
                field[j] = b[m];
                m++;
            }
        }
        k = 6 * pivotCount;
        while (k > disksCount) {
            k--;
            field[k] = 0;
        }
        if (round < 60000) {
            goodBoardFound = 1;
        } else {
            a2 = CalcOptim();
            if (a2 < disksCount - 9) {
                goodBoardFound = 1;
            }
            tloop = 0;
            i = microsoft_rand(pivotCount * 4);
            j = (b[i] - 1) % 7;
            if (j > 0) {
                j = b[i] - 1;
                k = 0;
                while (b[k] != j && k < disksCount) {
                    k++;
                }
                j = b[i + pivotCount];
                b[i + pivotCount] = b[k];
                b[k] = j;
            }
        }
    }
    if (pivotCount < 12) {
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < pivotCount; k++) {
                j = i * pivotCount + k;
                field[j] = b[m];
                m++;
            }
        }
        k = 6 * pivotCount;
        while (k > disksCount) {
            k--;
            field[k] = 0;
        }
    }
    window.status = "";
}

function loadBoard(idu, puz, status, lang_id) {
    lang_name = lang_id;
    pivotCount = status;
    if (pivotCount != 12 && pivotCount != 10 && pivotCount != 8) {
        pivotCount = 12;
    }
    typesCount = pivotCount - HELPER_PIVOTS;
    disksCount = TOWER_HEIGHT * typesCount;
    puzzle = puz;
    id_user = idu;
    gamestatus = 0;
    field = new Array(pivotCount * PIVOT_HEIGHT);
    movesHistory = new Array();
    scoresHistory = new Array();
    for (var k = 0; k < pivotCount; k++) {
        for (var i = 0; i < PIVOT_HEIGHT; i++) {
            var j = i * pivotCount + k;
            field[j] = 0;
        }
    }
    startGame();
}