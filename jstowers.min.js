var gxsize, gysize, ghrow, ghcol;
var num_t, num_r;
var atable, upCol, upRow, upLen;
var rnd, id_user;
var puzzle, score, optim, gamestatus = 0;
var undoR, hIstory;
var palitra = ['#003399', '#006600', '#d00000', '#c60095', '#009696', '#966400', '#b6dbde', '#f88000', '#e7f3a2', '#663300'];
var palitra_t = ['#3366cc', '#339933', '#ff3333', '#ff33cc', '#33cccc', '#cc9933', '#eeffff', '#ffbb33', '#ffffdd', '#996633'];
var palitra_r = ['#000055', '#002200', '#800000', '#860055', '#005656', '#562400', '#768b8e', '#a83000', '#97a362', '#260000'];
var color_digit = ['#c0c0b0', '#c0c0b0', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#0a0a0a', '#c0c0b0'];
var microsoft_rnd;
var gamehost;
var lang_name;
lang_name = 0;
gamehost = "http://bashni.org";

function microsoft_rnd() {
    var r;
    var big = 4294967295 + 1;
    microsoft_rnd.seed = (microsoft_rnd.seed * 214013 + 2531011) % big;
    r = microsoft_rnd.seed;
    r = Math.floor(r / 65536);
    r = r % 32768;
    return r;
}

function microsoft_rand(number) {
    return (microsoft_rnd()) % number;
};

function rnd() {
    rnd.seed = (rnd.seed * 9301 + 49297) % 233280;
    return rnd.seed / (233280.0);
};

function rand(number) {
    return Math.floor(rnd() * number);
};

function startGame() {
    user_input = puzzle;
    if (user_input > 0 && user_input < 1000000) {
        microsoft_rnd.seed = user_input;
    } else {
        microsoft_rnd.seed = 58;
        puzzle = 58;
        myform.puzzle.value = 58;
    }
    shuffle();
    score = 0;
    optim = CalcOptim() + score;
    upCol = -1;
    gamestatus = 1;
    showStatus();
}

function CalcOptim() {
    var a, i, k;
    var s = 0;
    for (k = 0; k < gxsize; k++) {
        i = 0;
        a = atable[i * gxsize + k];
        if (a > 0) {
            m1 = (a - 1) % 7;
            m2 = Math.floor((a - 1) / 7);
            if (m1 != 6) s++;
            i++;
            while ((a = atable[i * gxsize + k]) && i < gysize - 1) {
                k1 = (a - 1) % 7;
                k2 = Math.floor((a - 1) / 7);
                if (k2 == m2 && k1 == m1 - 1) {
                    s = s;
                } else {
                    s++;
                }
                m1 = k1;
                m2 = k2;
                i++;
            }
        }
    }
    return s;
}

function undo() {
    var j;
    if (score < 1) return;
    if (upCol >= 0) {
        DownCell(-1);
        return;
    }
    score--;
    hIstory[score] = 0;
    j = undoR[score];
    var rr1 = undoR[score] % 12;
    var rr2 = Math.floor(undoR[score] / 12) % 12;
    var cc1 = Math.floor(undoR[score] / 144) % 12;
    var cc2 = Math.floor(undoR[score] / (144 * 12)) % 12;
    for (j = 0; j < 7; j++) {
        var a = atable[(rr2 + j) * gxsize + cc2];
        if (a > 0) {
            atable[(rr1 + j) * gxsize + cc1] = a;
            atable[(rr2 + j) * gxsize + cc2] = 0;
            d = 0;
            if ((rr1 + j) > 0) {
                d = MergeCell((rr1 + j) * gxsize + cc1, (rr1 + j - 1) * gxsize + cc1);
            }
            setValue(rr1 + j, cc1, a, d);
            setValue(rr2 + j, cc2, 0, 0);
        }
    }
    optim = CalcOptim() + score;
    showStatus();
}

function saveUndo(cc1, cc2, rr1, rr2) {
    undoR[score] = rr1 + rr2 * 12 + cc1 * 144 + cc2 * 144 * 12;
}

function showStatus() {
    var vForecastStatus = document.getElementById('forecastStatus');
    var vUndoStatus = document.getElementById('undoStatus');
    if (gamestatus == 0) {
        vForecastStatus.innerHTML = "";
        vUndoStatus.innerHTML = "";
    } else {
        vForecastStatus.innerHTML = score + "[" + optim + "]";
        vUndoStatus.innerHTML = "<a class='undo' href='#'>Undo</a>";
    }
}

function showTable() {
    var i, j, s;
    var wwt = 63 * gxsize;
    s = "<table align='center' border='0' cellpadding='0' cellspacing='0' width='100%'><tr><td align='center' width='" + wwt + "'>";
    s = s + "<table  align='center' border='0' cellpadding='0' cellspacing='0'  width='" + wwt + "' bgcolor='#afaf5f' class='bigcell'>";
    for (i = 0; i < gysize; i++) {
        s = s + "<tr>";
        for (j = 0; j < gxsize; j++) {
            ck = 0;
            k = gysize - i - 1;
            s = s + "<td><dl class='dl2'>";
            s = s + "<dd id='a_" + k + "_" + j + "' onclick='move(this)' class='ground'>";
            s = s + "</dd></dl></td>";
        }
        s = s + "</tr>";
    }
    s = s + "</table>";
    s = s + "</td></tr></table>";
    return s;
}

function getCell(row, col) {
    var sCell = "a_" + row + "_" + col;
    var vCellElement = document.getElementById(sCell);
    return vCellElement;
}

function setValue(row, col, val, done) {
    var v = getCell(row, col);
    if (val) {
        var j = (val - 1) % 7;
        var w = j * 4 + 35;
        var p = (6 - j) * 2;
        var color = Math.floor((val - 1) / 7);
        var mean = 1 + (val - 1) % 7;
        if (j > 0) v.innerHTML = j;
        else v.innerHTML = " ";
        if (done) {
            v.className = "bricks";
            v.style.backgroundColor = palitra[color];
            v.style.borderBottomColor = palitra[color];
            v.style.borderLeftColor = palitra_t[color];
            v.style.borderRightColor = palitra_r[color];
            v.style.width = w + 'px';
            v.style.marginLeft = p + 'px';
            v.style.color = color_digit[color];
        } else {
            v.className = "bricks";
            v.style.backgroundColor = palitra[color];
            v.style.borderBottomColor = palitra_r[color];
            v.style.borderLeftColor = palitra_t[color];
            v.style.borderRightColor = palitra_r[color];
            v.style.width = w + 'px';
            v.style.marginLeft = p + 'px';
            v.style.color = color_digit[color];
        }
    } else {
        v.innerHTML = " ";
        v.className = "ground";
        v.style.width = '61px';
        v.style.marginLeft = '0px';
        v.style.backgroundColor = '#a87c58';
    }
}

function getValue(row, col) {
    var v = getCell(row, col);
    return v.innerHTML;
}

function getRow(obj) {
    var a = obj.id.split("_");
    return a[1];
}

function getCol(obj) {
    var a = obj.id.split("_");
    return a[2];
}

function MergeCell(c1, c2) {
    var i = 0;
    var a = atable[c1];
    var m1 = (a - 1) % 7;
    var m2 = Math.floor((a - 1) / 7);
    a = atable[c2];
    var k1 = (a - 1) % 7;
    var k2 = Math.floor((a - 1) / 7);
    if (k2 == m2 && k1 == m1 + 1) i = 1;
    return i;
}

function GetUp(col) {
    col = parseInt(col);
    if (col < 0) return -2;
    if (col > 11) return -2;
    var s = 0;
    var i = 0;
    while ((a = atable[i * gxsize + col]) && i < gysize - 1) {
        i++;
    }
    s = i - 1;
    return s;
}

function GetH(col, r) {
    h = 0;
    i = r;
    while (i >= 0) {
        h++;
        a = atable[i * gxsize + col];
        m1 = (a - 1) % 7;
        m2 = Math.floor((a - 1) / 7);
        i--;
        if (i >= 0) {
            a = atable[i * gxsize + col];
            k1 = (a - 1) % 7;
            k2 = Math.floor((a - 1) / 7);
            if (!(k2 == m2 && k1 == m1 + 1)) i = -1;
        }
    }
    return h;
}

function UpCell(col) {
    var i;
    col = parseInt(col);
    r = GetUp(col);
    if (r >= 0) {
        h = 1;
        if (r > 0) {
            h = GetH(col, r);
        }
        upCol = col;
        upRow = r - h + 1;
        upLen = h;
        for (j = 0; j < h; j++) {
            setValue(upRow + j, col, 0, 0);
        }
        i = col + (upRow) * gxsize;
        setValue(gysize - 1, col, atable[i], 0);
    }
}

function DownCell(col) {
    var i, a, m1, m2, k1, k2;
    col = parseInt(col);
    var canput = 0;
    var r = GetUp(col);
    if (r >= 0) {
        a = atable[r * gxsize + col];
        m1 = (a - 1) % 7;
        m2 = Math.floor((a - 1) / 7);
        a = atable[upRow * gxsize + upCol];
        k1 = (a - 1) % 7;
        k2 = Math.floor((a - 1) / 7);
        if (k2 == m2 && k1 < m1) {
            canput = 1;
        }
    } else {
        canput = 1;
    }
    if (r == -2) canput = 0;
    if (canput) {
        for (j = 0; j < upLen; j++) {
            var a = atable[(upRow + j) * gxsize + upCol];
            atable[(r + 1 + j) * gxsize + col] = a;
            atable[(upRow + j) * gxsize + upCol] = 0;
            d = 0;
            if ((r + j) >= 0) {
                d = MergeCell((r + 1 + j) * gxsize + col, (r + j) * gxsize + col);
            }
            setValue(r + 1 + j, col, a, d);
        }
        setValue(gysize - 1, upCol, 0, 0);
        saveUndo(upCol, col, upRow, r + 1);
        hIstory[score] = upCol + col * 12;
        score++;
    } else {
        for (j = 0; j < upLen; j++) {
            a = atable[(upRow + j) * gxsize + upCol];
            d = 0;
            if ((upRow + j) > 0) {
                d = MergeCell((upRow + j) * gxsize + upCol, (upRow + j - 1) * gxsize + upCol);
            }
            setValue(upRow + j, upCol, a, d);
        }
        setValue(gysize - 1, upCol, 0, 0);
    }
    optim = CalcOptim() + score;
    upCol = -1;
    showStatus();
    if (checkEnd()) {
        gamestatus = 0;
        saveResult();
    }
}

function checkEnd() {
    var i;
    if (score > 199) {
        return 1;
    }
    for (i = 0; i < gxsize; i++) {
        var r = GetUp(i);
        if (r >= 0) {
            j = 0;
            var a = atable[j * gxsize + i];
            var m2 = Math.floor((a - 1) / 7);
            for (j = 0; j < 7; j++) {
                var a = atable[j * gxsize + i];
                k1 = (a - 1) % 7;
                k2 = Math.floor((a - 1) / 7);
                if (k2 != m2) return 0;
                if (k1 != 6 - j) return 0;
            }
        }
    }
    return 1;
}

function saveResult() {
    var i, k;
    hist = '';
    i = 0;
    while (hIstory[i] > 0) {
        k = hIstory[i] % 12;
        if (k == 10) {
            hist = hist + 'A';
        }
        if (k == 11) {
            hist = hist + 'B';
        }
        if (k < 10) {
            hist = hist + k;
        }
        k = Math.floor(hIstory[i] / 12);
        if (k == 10) {
            hist = hist + 'A';
        }
        if (k == 11) {
            hist = hist + 'B';
        }
        if (k < 10) {
            hist = hist + k;
        }
        i++;
    }
    s = gamehost + '/cgi-bin/savescore_drupal.pl?id=' + id_user;
    s = s + '&score=' + score;
    s = s + '&puzzle=' + puzzle;
    s = s + '&status=' + gxsize;
    s = s + '&h=' + hist;
    s = s + '&lang=' + lang_name;
    window.location.replace(s);
}

function move(obj) {
    var r, c, hr, hc;
    if (gamestatus < 1) {
        return;
    }
    r12 = getRow(obj);
    c12 = getCol(obj);
    if (upCol >= 0) {
        DownCell(c12);
    } else {
        UpCell(c12);
    }
    return;
}

function shuffle() {
    var t, i, j, s, frac, a2, tloop;
    window.status = "Loading ";
    var b = new Array(72);
    for (k = 0; k < 72; k++) {
        b[k] = k + 1;
    }
    for (k = 0; k < gxsize; k++) {
        for (i = 0; i < gysize; i++) {
            j = i * gxsize + k;
            atable[j] = 0;
        }
    }
    fround = 0;
    tloop = 2300;
    var round = puzzle;
    var cic = 0,
        cic2 = 0;
    while (!fround) {
        cic++;
        if (cic == 1000) {
            cic2++;
            window.status = "Loading " + cic2 + "%";
            cic = 0;
        }
        for (k = 0; k < tloop; k++) {
            i = microsoft_rand(num_r);
            j = microsoft_rand(num_r);
            m = b[i];
            b[i] = b[j];
            b[j] = m;
        }
        tloop = 1;
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < gxsize; k++) {
                j = i * gxsize + k;
                atable[j] = b[m];
                m++;
            }
        }
        k = 6 * gxsize;
        while (k > num_r) {
            k--;
            atable[k] = 0;
        }
        if (round < 60000) {
            fround = 1;
        } else {
            a2 = CalcOptim();
            if (a2 < num_r - 9) fround = 1;
            tloop = 0;
            i = microsoft_rand(gxsize * 4);
            j = (b[i] - 1) % 7;
            if (j > 0) {
                j = b[i] - 1;
                k = 0;
                while (b[k] != j && k < num_r) k++;
                j = b[i + gxsize];
                b[i + gxsize] = b[k];
                b[k] = j;
            }
        }
    }
    if (gxsize < 12) {
        m = 0;
        for (i = 0; i < 6; i++) {
            for (k = 0; k < gxsize; k++) {
                j = i * gxsize + k;
                atable[j] = b[m];
                m++;
            }
        }
        k = 6 * gxsize;
        while (k > num_r) {
            k--;
            atable[k] = 0;
        }
    }
    for (k = 0; k < gxsize; k++) {
        for (i = 0; i < gysize; i++) {
            j = i * gxsize + k;
            m = atable[j];
            d = 0;
            if (i > 0 && m > 0) {
                d = MergeCell(j, j - gxsize);
            }
            setValue(i, k, m, d);
        }
    }
    window.status = "";
}

function loadBoard(idu, puz, status, lang_id) {
    var i, j, m, k;
    lang_name = lang_id;
    gxsize = status;
    if (gxsize != 12 && gxsize != 10 && gxsize != 8) gxsize = 12;
    gysize = 14;
    num_t = gxsize - 2;
    num_r = 7 * num_t;
    puzzle = puz;
    id_user = idu;
    gamestatus = 0;
    atable = new Array(200);
    undoR = new Array(205);
    hIstory = new Array(205);
    for (k = 0; k < 205; k++) {
        undoR[k] = 0;
        hIstory[k] = 0;
    }
    for (k = 0; k < gxsize; k++) {
        for (i = 0; i < gysize; i++) {
            j = i * gxsize + k;
            atable[j] = 0;
        }
    }
    var vBoard = document.getElementById('board');
    vBoard.innerHTML = showTable(gxsize, gysize, atable);
    startGame();
}